<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sonic Speedtest</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&display=swap');

        body {
            font-family: 'Outfit', sans-serif;
        }

        .gauge-circle {
            transition: stroke-dashoffset 0.3s ease;
        }
    </style>
</head>

<body class="bg-slate-900 text-white min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Header -->
    <header class="absolute top-0 w-full p-6 flex justify-between items-center opacity-80">
        <h1 class="text-2xl font-bold tracking-wider text-cyan-400">SONIC<span class="text-white">SPEED</span></h1>
        <div class="text-xs text-slate-400">SERVER: LOCALHOST</div>
    </header>

    <!-- Main Display -->
    <main class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-3 gap-8 text-center relative z-10">

        <!-- PING -->
        <div
            class="bg-slate-800/50 backdrop-blur-md border border-slate-700 rounded-2xl p-6 flex flex-col items-center justify-center shadow-lg hover:border-cyan-500/50 transition-colors">
            <h2 class="text-slate-400 text-sm uppercase tracking-widest mb-2">Ping</h2>
            <div class="text-4xl font-bold flex items-end">
                <span id="pingVal">--</span>
                <span class="text-lg text-slate-500 ml-1 font-normal mb-1">ms</span>
            </div>
            <div class="text-xs text-slate-500 mt-2">Jitter: <span id="jitterVal">--</span> ms</div>
        </div>

        <!-- MAIN GAUGE -->
        <div class="md:col-span-1 flex flex-col items-center justify-center relative">
            <div class="relative w-64 h-64 flex items-center justify-center">
                <svg class="absolute w-full h-full transform -rotate-90" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="45" fill="none" stroke="#1e293b" stroke-width="6" />
                    <circle id="speedGauge" cx="50" cy="50" r="45" fill="none" stroke="#22d3ee" stroke-width="6"
                        stroke-dasharray="283" stroke-dashoffset="283" stroke-linecap="round" class="gauge-circle" />
                </svg>
                <div class="z-10 text-center">
                    <div id="mainSpeedVal"
                        class="text-6xl font-bold tracking-tighter text-white drop-shadow-[0_0_15px_rgba(34,211,238,0.5)]">
                        0.0</div>
                    <div class="text-cyan-400 text-sm font-semibold tracking-widest mt-1">Mbps</div>
                </div>
            </div>

            <button id="startBtn" onclick="startTest()"
                class="mt-8 px-12 py-4 bg-cyan-500 hover:bg-cyan-400 text-slate-900 font-bold rounded-full shadow-[0_0_20px_rgba(34,211,238,0.3)] transition-all transform hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed">
                GO
            </button>
            <div id="statusText" class="mt-4 text-cyan-400 h-6 text-sm animate-pulse font-mono"></div>
        </div>

        <!-- UPLOAD -->
        <div
            class="bg-slate-800/50 backdrop-blur-md border border-slate-700 rounded-2xl p-6 flex flex-col items-center justify-center shadow-lg hover:border-purple-500/50 transition-colors">
            <h2 class="text-slate-400 text-sm uppercase tracking-widest mb-2">Upload</h2>
            <div class="text-4xl font-bold flex items-end">
                <span id="uploadVal">--</span>
                <span class="text-lg text-slate-500 ml-1 font-normal mb-1">Mbps</span>
            </div>
            <div class="text-xs text-slate-500 mt-2 opacity-0">.</div>
        </div>

    </main>

    <!-- Footer -->
    <div class="absolute bottom-8 text-slate-500 text-xs flex gap-6">
        <span>provider: Local Network</span>
        <span>host: Golang Native</span>
    </div>

    <!-- History Section -->
    <div id="historySection" class="w-full max-w-4xl mt-12 mb-24 z-10 hidden">
        <div class="flex justify-between items-center mb-4 border-b border-slate-700 pb-2">
            <h3 class="text-xl text-cyan-400 font-semibold tracking-wide">HISTORY</h3>
            <button onclick="clearHistory()"
                class="text-xs text-rose-400 hover:text-white transition-colors uppercase tracking-widest">Clear
                History</button>
        </div>
        <div class="overflow-x-auto rounded-lg border border-slate-700 bg-slate-800/30 backdrop-blur-sm">
            <table class="w-full text-left text-sm text-slate-400">
                <thead class="bg-slate-700/50 text-xs uppercase text-slate-200">
                    <tr>
                        <th class="px-6 py-3">Date</th>
                        <th class="px-6 py-3 text-right">Ping <span class="text-[0.6rem] text-slate-500">(ms)</span>
                        </th>
                        <th class="px-6 py-3 text-right">Download <span
                                class="text-[0.6rem] text-slate-500">(Mbps)</span></th>
                        <th class="px-6 py-3 text-right">Upload <span class="text-[0.6rem] text-slate-500">(Mbps)</span>
                        </th>
                    </tr>
                </thead>
                <tbody id="historyTableBody" class="divide-y divide-slate-700/50">
                    <!-- Rows injected here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const API = { ping: '/api/ping', download: '/api/download', upload: '/api/upload' };
        const ELS = {
            startBtn: document.getElementById('startBtn'),
            status: document.getElementById('statusText'),
            ping: document.getElementById('pingVal'),
            jitter: document.getElementById('jitterVal'),
            mainSpeed: document.getElementById('mainSpeedVal'),
            upload: document.getElementById('uploadVal'),
            gauge: document.getElementById('speedGauge'),
            historySection: document.getElementById('historySection'),
            historyTableBody: document.getElementById('historyTableBody')
        };

        const DB_NAME = 'SonicDB', DB_VERSION = 1, STORE_NAME = 'results', GAUGE_CIRCUMFERENCE = 283;
        let db;

        // IndexedDB
        const initDB = () => new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (e) => {
                db = e.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                }
            };
            request.onsuccess = (e) => { db = e.target.result; loadHistory(); resolve(db); };
            request.onerror = (e) => reject(e);
        });

        const addResult = async (res) => {
            const tx = db.transaction([STORE_NAME], 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            store.add({ ...res, timestamp: new Date() });
            tx.oncomplete = () => { pruneHistory(); loadHistory(); };
        };

        const pruneHistory = () => {
            const tx = db.transaction([STORE_NAME], 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            const countReq = store.count();
            countReq.onsuccess = () => {
                if (countReq.result > 10) {
                    const keyReq = store.getAllKeys();
                    keyReq.onsuccess = () => {
                        const keys = keyReq.result;
                        const toDelete = keys.length - 10;
                        if (toDelete > 0) {
                            const delTx = db.transaction([STORE_NAME], 'readwrite');
                            const delStore = delTx.objectStore(STORE_NAME);
                            for (let i = 0; i < toDelete; i++) { delStore.delete(keys[i]); }
                        }
                    }
                }
            }
        };

        const loadHistory = () => {
            if (!db) return;
            const tx = db.transaction([STORE_NAME], 'readonly');
            const store = tx.objectStore(STORE_NAME);
            const req = store.getAll();
            req.onsuccess = () => renderHistory(req.result);
        };

        const clearHistory = () => {
            const tx = db.transaction([STORE_NAME], 'readwrite');
            tx.objectStore(STORE_NAME).clear();
            tx.oncomplete = () => loadHistory();
        };

        const renderHistory = (items) => {
            if (!items || items.length === 0) {
                ELS.historySection.classList.add('hidden');
                return;
            }
            ELS.historySection.classList.remove('hidden');
            items.sort((a, b) => b.id - a.id);
            ELS.historyTableBody.innerHTML = items.map(item => `
                <tr class="hover:bg-slate-700/30 transition-colors">
                    <td class="px-6 py-4">${new Date(item.timestamp).toLocaleString()}</td>
                    <td class="px-6 py-4 text-right font-mono text-cyan-400">${item.ping}</td>
                    <td class="px-6 py-4 text-right font-mono text-white font-bold">${item.download}</td>
                    <td class="px-6 py-4 text-right font-mono text-purple-400">${item.upload}</td>
                </tr>
            `).join('');
        };

        window.addEventListener('load', initDB);

        function setGauge(percentage) {
            const offset = GAUGE_CIRCUMFERENCE - (percentage / 100 * GAUGE_CIRCUMFERENCE);
            ELS.gauge.style.strokeDashoffset = offset;
        }

        const fmtSpeed = (mbps) => mbps.toFixed(1);
        async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        async function runPing() {
            ELS.status.innerText = "MEASURING PING...";
            const pings = [];
            for (let i = 0; i < 10; i++) {
                const start = performance.now();
                await fetch(`${API.ping}?nocache=${start}`);
                const end = performance.now();
                pings.push(end - start);
                await sleep(50);
            }
            const min = Math.min(...pings);
            const avg = pings.reduce((a, b) => a + b, 0) / pings.length;
            const jitter = pings.reduce((a, b) => a + Math.abs(b - avg), 0) / pings.length;
            ELS.ping.innerText = min.toFixed(0);
            ELS.jitter.innerText = jitter.toFixed(1);
            return { min, jitter };
        }

        async function runDownload() {
            ELS.status.innerText = "MEASURING DOWNLOAD...";
            ELS.gauge.style.stroke = "#22d3ee";
            const threads = 4, targetDuration = 5000, bufferSize = 4 * 1024 * 1024;
            let totalBytes = 0, startTime = performance.now(), running = true;

            const uiInterval = setInterval(() => {
                const duration = (performance.now() - startTime) / 1000;
                if (!duration) return;
                const speedMbps = ((totalBytes * 8) / duration) / 1000000;
                ELS.mainSpeed.innerText = fmtSpeed(speedMbps);
                setGauge(Math.min((speedMbps / 1000) * 100, 100));
            }, 100);

            const worker = async () => {
                while (running && (performance.now() - startTime) < targetDuration) {
                    try {
                        const response = await fetch(`${API.download}?size=${bufferSize}&nocache=${Date.now()}`);
                        const reader = response.body.getReader();
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            totalBytes += value.length;
                            if (!running) { reader.cancel(); break; }
                        }
                    } catch (e) { console.error(e); break; }
                }
            };

            await Promise.all(Array(threads).fill(null).map(worker));
            running = false;
            clearInterval(uiInterval);
            const finalSpeedMbps = ((totalBytes * 8) / ((performance.now() - startTime) / 1000)) / 1000000;
            ELS.mainSpeed.innerText = fmtSpeed(finalSpeedMbps);
            setGauge(0);
            return finalSpeedMbps;
        }

        async function runUpload() {
            ELS.status.innerText = "PREPARING UPLOAD...";
            ELS.mainSpeed.innerText = "0.0";
            ELS.gauge.style.stroke = "#a855f7";
            await sleep(500);
            ELS.status.innerText = "MEASURING UPLOAD...";

            const size = 10 * 1024 * 1024, payload = new Uint8Array(size), blob = new Blob([payload]);
            const threads = 3, targetDuration = 5000;
            let totalBytes = 0, startTime = performance.now(), running = true;

            const uiInterval = setInterval(() => {
                const duration = (performance.now() - startTime) / 1000;
                if (duration <= 0) return;
                const speedMbps = ((totalBytes * 8) / duration) / 1000000;
                ELS.mainSpeed.innerText = fmtSpeed(speedMbps);
                setGauge(Math.min((speedMbps / 1000) * 100, 100));
            }, 100);

            const worker = async () => {
                while (running && (performance.now() - startTime) < targetDuration) {
                    try {
                        await fetch(API.upload, { method: 'POST', body: blob, cache: 'no-store' });
                        if (!running) break;
                        totalBytes += size;
                    } catch (e) { console.error(e); break; }
                }
            };

            await Promise.all(Array(threads).fill(null).map(worker));
            running = false;
            clearInterval(uiInterval);
            const finalSpeedMbps = ((totalBytes * 8) / ((performance.now() - startTime) / 1000)) / 1000000;
            ELS.upload.innerText = fmtSpeed(finalSpeedMbps);
            ELS.mainSpeed.innerText = "--";
            setGauge(0);
            return finalSpeedMbps;
        }

        async function startTest() {
            if (ELS.startBtn.disabled) return;
            ELS.startBtn.disabled = true;
            ELS.startBtn.innerText = "RUNNING";
            ELS.ping.innerText = "--";
            ELS.jitter.innerText = "--";
            ELS.mainSpeed.innerText = "0.0";
            ELS.upload.innerText = "--";

            try {
                const pingRes = await runPing();
                await sleep(500);
                const dlSpeed = await runDownload();
                await sleep(1000);
                const ulSpeed = await runUpload();
                ELS.status.innerText = "TEST COMPLETE";

                await addResult({
                    ping: pingRes.min.toFixed(0),
                    jitter: pingRes.jitter.toFixed(1),
                    download: dlSpeed.toFixed(1),
                    upload: ulSpeed.toFixed(1)
                });
            } catch (e) {
                console.error(e);
                ELS.status.innerText = "ERROR";
            } finally {
                ELS.startBtn.disabled = false;
                ELS.startBtn.innerText = "GO";
                ELS.gauge.style.stroke = "#22d3ee";
            }
        }
    </script>
</body>

</html>